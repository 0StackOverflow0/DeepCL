#include "Propagate1.h"
#include "stringhelper.h"

using namespace std;

#undef VIRTUAL
#undef STATIC
#define VIRTUAL
#define STATIC

Propagate1::Propagate1( OpenCLHelper *cl, LayerDimensions dim, ActivationFunction const*fn ) :
        Propagate( cl, dim, fn )
            {
    // [[[cog
    // import stringify
    // stringify.write_kernel( "kernelSource", "ClConvolve.cl")
    // ]]]
    const char * kernelSource =  
    "// Copyright Hugh Perkins 2014 hughperkins at gmail\n" 
    "//\n" 
    "// This Source Code Form is subject to the terms of the Mozilla Public License,\n" 
    "// v. 2.0. If a copy of the MPL was not distributed with this file, You can\n" 
    "// obtain one at http://mozilla.org/MPL/2.0/.\n" 
    "\n" 
    "// expected defines:\n" 
    "// one of: [ TANH | RELU | LINEAR ]\n" 
    "// BIASED (or not)\n" 
    "\n" 
    "#ifdef TANH\n" 
    "#define ACTIVATION_FUNCTION(output) (tanh(output))\n" 
    "#define ACTIVATION_DERIV(output) (1 - output * output)\n" 
    "#elif defined RELU\n" 
    "#define ACTIVATION_FUNCTION(output) (output> 0 ? output : 0)\n" 
    "#define ACTIVATION_DERIV(output) (output > 0 ? 1 : 0)\n" 
    "#elif defined LINEAR\n" 
    "#define ACTIVATION_FUNCTION(output) (output)\n" 
    "#define ACTIVATION_DERIV(output) (1)\n" 
    "#endif\n" 
    "\n" 
    "void kernel convolve_ints( global const int *p_boardSize, global const int *p_filterSize,\n" 
    "global const int *image, global const int *filter, global int *result ) {\n" 
    "int id = get_global_id(0);\n" 
    "int boardSize = p_boardSize[0];\n" 
    "int filterSize = p_filterSize[0];\n" 
    "int boardOffset = id / (boardSize * boardSize ) * (boardSize * boardSize );\n" 
    "int localid = id % (boardSize * boardSize );\n" 
    "int row = localid / boardSize;\n" 
    "int col = localid % boardSize;\n" 
    "int halfFilterSize = filterSize >> 1;\n" 
    "int sum = 0;\n" 
    "int minm = max( -halfFilterSize, -row );\n" 
    "int maxm = min( halfFilterSize, boardSize - 1 - row );\n" 
    "int minn = max( -halfFilterSize, -col );\n" 
    "int maxn = min( halfFilterSize, boardSize - 1 - col );\n" 
    "int m = minm;\n" 
    "while( m <= maxm ) {\n" 
    "int x = ( row + m );\n" 
    "int xboard = boardOffset + x * boardSize;\n" 
    "int filterrowoffset = (m+halfFilterSize) * filterSize + halfFilterSize;\n" 
    "int n = minn;\n" 
    "while( n <= maxn ) {\n" 
    "int y = col + n;\n" 
    "sum += image[ xboard + y] * filter[ filterrowoffset + n ];\n" 
    "n++;\n" 
    "}\n" 
    "m++;\n" 
    "}\n" 
    "result[id] = sum;\n" 
    "}\n" 
    "\n" 
    "void kernel convolve_floats( global const int *p_boardSize, global const int *p_filterSize,\n" 
    "global const float *image, global const float *filter, global float *result ) {\n" 
    "int id = get_global_id(0);\n" 
    "int boardSize = p_boardSize[0];\n" 
    "int filterSize = p_filterSize[0];\n" 
    "int boardOffset = id / (boardSize * boardSize ) * (boardSize * boardSize );\n" 
    "int localid = id % (boardSize * boardSize );\n" 
    "int row = localid / boardSize;\n" 
    "int col = localid % boardSize;\n" 
    "int halfFilterSize = filterSize >> 1;\n" 
    "float sum = 0;\n" 
    "int minm = max( -halfFilterSize, -row );\n" 
    "int maxm = min( halfFilterSize, boardSize - 1 - row );\n" 
    "int minn = max( -halfFilterSize, -col );\n" 
    "int maxn = min( halfFilterSize, boardSize - 1 - col );\n" 
    "int m = minm;\n" 
    "while( m <= maxm ) {\n" 
    "int x = ( row + m );\n" 
    "int xboard = boardOffset + x * boardSize;\n" 
    "int filterrowoffset = (m+halfFilterSize) * filterSize + halfFilterSize;\n" 
    "int n = minn;\n" 
    "while( n <= maxn ) {\n" 
    "int y = col + n;\n" 
    "sum += image[ xboard + y] * filter[ filterrowoffset + n ];\n" 
    "n++;\n" 
    "}\n" 
    "m++;\n" 
    "}\n" 
    "result[id] = sum;\n" 
    "}\n" 
    "\n" 
    "void kernel convolve_imagecubes_int( global const int *p_numInputPlanes, global const int *p_numFilters,\n" 
    "global const int *p_boardSize, global const int *p_filterSize,\n" 
    "global const int *images, global const int *filters, global int *results ) {\n" 
    "int globalId = get_global_id(0);\n" 
    "\n" 
    "int numInputPlanes = p_numInputPlanes[0];\n" 
    "int numFilters = p_numFilters[0];\n" 
    "int boardSize = p_boardSize[0];\n" 
    "int filterSize = p_filterSize[0];\n" 
    "int boardSizeSquared = boardSize * boardSize;\n" 
    "\n" 
    "int outputBoard2Id = globalId / boardSizeSquared;\n" 
    "int filterId = outputBoard2Id % numFilters;\n" 
    "int inputBoard3Id = outputBoard2Id / numFilters;\n" 
    "\n" 
    "int filterOffset = filterId * filterSize * filterSize;\n" 
    "int inputBoard3Offset = inputBoard3Id * numInputPlanes * boardSizeSquared;\n" 
    "\n" 
    "// intraboard coords\n" 
    "int localid = globalId % boardSizeSquared;\n" 
    "int row = localid / boardSize;\n" 
    "int col = localid % boardSize;\n" 
    "\n" 
    "int halfFilterSize = filterSize >> 1;\n" 
    "int sum = 0;\n" 
    "int minm = max( -halfFilterSize, -row );\n" 
    "int maxm = min( halfFilterSize, boardSize - 1 - row );\n" 
    "int minn = max( -halfFilterSize, -col );\n" 
    "int maxn = min( halfFilterSize, boardSize - 1 - col );\n" 
    "int plane = 0;\n" 
    "while( plane < numInputPlanes ) {\n" 
    "int inputBoardOffset = inputBoard3Offset + plane * boardSizeSquared;\n" 
    "int filterPlaneOffset = filterOffset + plane * filterSize * filterSize;\n" 
    "int m = minm;\n" 
    "while( m <= maxm ) {\n" 
    "int y = row + m;\n" 
    "int inputboardrowoffset = inputBoardOffset + y * boardSize;\n" 
    "int filterrowoffset = filterPlaneOffset + (m+halfFilterSize) * filterSize + halfFilterSize;\n" 
    "int n = minn;\n" 
    "while( n <= maxn ) {\n" 
    "int x = col + n;\n" 
    "sum += images[ inputboardrowoffset + x] * filters[ filterrowoffset + n ];\n" 
    "n++;\n" 
    "}\n" 
    "m++;\n" 
    "}\n" 
    "plane++;\n" 
    "}\n" 
    "results[globalId] = sum;\n" 
    "}\n" 
    "\n" 
    "// receive images as a stack of images\n" 
    "// globalid = n * numfilters * boardsize * boardsize + filter * boardsize * boardsize + imagerow * boardsize + imagecol\n" 
    "//                                 globalid              globalid\n" 
    "//  inputboard3 1 inputboard2 1----filter 1             -> outputboard2 1   outputboard3 1\n" 
    "//                inputboard2 2_/\\_filter 2             -> outputboard2 2\n" 
    "//  inputboard3 2 inputboard2 3    filter 1             -> outputboard2 3   outputboard3 2\n" 
    "//                inputboard2 4    filter 2             -> outputboard2 4\n" 
    "//\n" 
    "// each outputboard is only written once, by a combination of:\n" 
    "// - one inputboard3\n" 
    "// - one filter\n" 
    "// each inputboard3 is mapped to each filter once, each time writing to one outputboard\n" 
    "//\n" 
    "// images is:\n" 
    "//       numimages * numinputplanes * boardsizesquared\n" 
    "// filters is:\n" 
    "//       numfilters * numinputplanes * filtersizesquared\n" 
    "// outputs is:\n" 
    "//       numimages * numfilters * outputboardsizesquared\n" 
    "\n" 
    "// images are organized like [imageId][plane][row][col]\n" 
    "// filters are organized like [filterid][plane][filterrow][filtercol]\n" 
    "// results are organized like [imageid][filterid][row][col]\n" 
    "void kernel convolve_imagecubes_float(\n" 
    "const int numInputPlanes, const int numFilters,\n" 
    "const int boardSize, const int filterSize,\n" 
    "global const float *images, global const float *filters, global float *results ) {\n" 
    "int globalId = get_global_id(0);\n" 
    "\n" 
    "int boardSizeSquared = boardSize * boardSize;\n" 
    "\n" 
    "int outputBoard2Id = globalId / boardSizeSquared;\n" 
    "int filterId = outputBoard2Id % numFilters;\n" 
    "int inputBoard3Id = outputBoard2Id / numFilters;\n" 
    "\n" 
    "int filterOffset = filterId * filterSize * filterSize;\n" 
    "int inputBoard3Offset = inputBoard3Id * numInputPlanes * boardSizeSquared;\n" 
    "\n" 
    "// intraboard coords\n" 
    "int localid = globalId % boardSizeSquared;\n" 
    "int row = localid / boardSize;\n" 
    "int col = localid % boardSize;\n" 
    "\n" 
    "int halfFilterSize = filterSize >> 1;\n" 
    "float sum = 0;\n" 
    "// m should vary from -halfFilterSize through 0 to halfFilterSize\n" 
    "// n too...\n" 
    "int minm = max( -halfFilterSize, -row );\n" 
    "int maxm = min( halfFilterSize, boardSize - 1 - row );\n" 
    "int minn = max( -halfFilterSize, -col );\n" 
    "int maxn = min( halfFilterSize, boardSize - 1 - col );\n" 
    "int inputPlane = 0;\n" 
    "while( inputPlane < numInputPlanes ) {\n" 
    "int inputBoardOffset = inputBoard3Offset + inputPlane * boardSizeSquared;\n" 
    "int m = minm;\n" 
    "while( m <= maxm ) {\n" 
    "int y = row + m;\n" 
    "int inputboardrowoffset = inputBoardOffset + y * boardSize;\n" 
    "int filterrowoffset = filterOffset + (m+halfFilterSize) * filterSize + halfFilterSize;\n" 
    "int n = minn;\n" 
    "while( n <= maxn ) {\n" 
    "int x = col + n;\n" 
    "sum += images[ inputboardrowoffset + x] * filters[ filterrowoffset + n ];\n" 
    "n++;\n" 
    "}\n" 
    "m++;\n" 
    "}\n" 
    "inputPlane++;\n" 
    "}\n" 
    "\n" 
    "results[globalId] = sum;\n" 
    "}\n" 
    "\n" 
    "void kernel convolve_imagecubes_float_nopadzeros(\n" 
    "const int numInputPlanes, const int numFilters,\n" 
    "const int inputBoardSize, const int filterSize,\n" 
    "global const float *images, global const float *filters, global float *results ) {\n" 
    "int globalId = get_global_id(0);\n" 
    "\n" 
    "int inputBoardSizeSquared = inputBoardSize * inputBoardSize;\n" 
    "int outputBoardSize = inputBoardSize - filterSize + 1;\n" 
    "int outputBoardSizeSquared = outputBoardSize * outputBoardSize;\n" 
    "\n" 
    "int outputBoard2Id = globalId / outputBoardSizeSquared;\n" 
    "int filterId = outputBoard2Id % numFilters;\n" 
    "int inputBoard3Id = outputBoard2Id / numFilters;\n" 
    "\n" 
    "int filterOffset = filterId * filterSize * filterSize;\n" 
    "int inputBoard3Offset = inputBoard3Id * numInputPlanes * inputBoardSizeSquared;\n" 
    "\n" 
    "// intraboard coords\n" 
    "int localid = globalId % outputBoardSizeSquared;\n" 
    "int outputRow = localid / outputBoardSize;\n" 
    "int outputCol = localid % outputBoardSize;\n" 
    "\n" 
    "int halfFilterSize = filterSize >> 1;\n" 
    "float sum = 0;\n" 
    "int minm = -halfFilterSize;\n" 
    "int maxm = halfFilterSize;\n" 
    "int minn = -halfFilterSize;\n" 
    "int maxn = halfFilterSize;\n" 
    "int inputPlane = 0;\n" 
    "while( inputPlane < numInputPlanes ) {\n" 
    "int inputBoardOffset = inputBoard3Offset + inputPlane * inputBoardSizeSquared;\n" 
    "int m = minm;\n" 
    "while( m <= maxm ) {\n" 
    "int inputRow = outputRow + m + halfFilterSize;\n" 
    "int inputboardrowoffset = inputBoardOffset + inputRow * inputBoardSize;\n" 
    "int filterrowoffset = filterOffset + (m+halfFilterSize) * filterSize + halfFilterSize;\n" 
    "int n = minn;\n" 
    "while( n <= maxn ) {\n" 
    "int inputCol = outputCol + n + halfFilterSize;\n" 
    "sum += images[ inputboardrowoffset + inputCol] * filters[ filterrowoffset + n ];\n" 
    "n++;\n" 
    "}\n" 
    "m++;\n" 
    "}\n" 
    "inputPlane++;\n" 
    "}\n" 
    "results[globalId] = sum;\n" 
    "}\n" 
    "\n" 
    "// notes on non-odd filtersizes:\n" 
    "// for odd, boardsize and filtersize 3, padZeros = 0:\n" 
    "// output is a single square\n" 
    "// m and n should vary between -1,0,1\n" 
    "// for even, boardsize and filtersize 2, padzeros = 0\n" 
    "// output is a single square, which we can position at topleft or bottomrigth\n" 
    "// lets position it in bottomright\n" 
    "// then m and n should vary as -1,0\n" 
    "//\n" 
    "// for even, boardsize and filtersize 2, padzeros = 1\n" 
    "// output is 2 by 2\n" 
    "// well... if it is even:\n" 
    "// - if we are not padding zeros, then we simply move our filter around the board somehow\n" 
    "// - if we are padding zeros, then we conceptually pad the bottom and right edge of the board with zeros by 1\n" 
    "// filtersize remains the same\n" 
    "//      m will vary as -1,0,1\n" 
    "//       outputrow is fixed by globalid\n" 
    "//       inputrow should be unchanged...\n" 
    "// padzeros = 0:\n" 
    "//  x x .  . . .\n" 
    "//  x x .  . x x\n" 
    "//  . . .  . x x\n" 
    "// when filtersize even:\n" 
    "//    new boardsize = oldboardsize - filtersize + 1\n" 
    "// when filtersize odd:\n" 
    "//    x x x .\n" 
    "//    x x x .\n" 
    "//    x x x .\n" 
    "//    . . . .\n" 
    "//    new boardsize = oldboardsize - filtersize + 1\n" 
    "// padzeros = 1:\n" 
    "// x x\n" 
    "// x x . .   x x .    . . .     . . .\n" 
    "//   . . .   x x .    . x x     . . .\n" 
    "//   . . .   . . .    . x x     . . x x\n" 
    "// outrow=0 outrow=1  outrow=2      x x\n" 
    "// outcol=0 outcol=1  outcol=2    outrow=3\n" 
    "//                                outcol=3\n" 
    "// when filtersize is even, and padzeros, boardsize grows by 1 each time...\n" 
    "//    boardsize = oldboardsize + 1\n" 
    "// when filtersize is odd\n" 
    "//  x x x\n" 
    "//  x x x .   x x x    . . .\n" 
    "//  x x x .   x x x    . x x x\n" 
    "//    . . .   x x x    . x x x\n" 
    "//                       x x x\n" 
    "\n" 
    "// images are organized like [imageId][plane][row][col]\n" 
    "// filters are organized like [filterid][inplane][filterrow][filtercol]\n" 
    "// results are organized like [imageid][filterid][row][col]\n" 
    "// global id is organized like results, ie: [imageid][outplane][outrow][outcol]\n" 
    "// - no local memory used currently\n" 
    "// - each thread:\n" 
    "//     - loads a whole upstream cube\n" 
    "//     - loads a whole filter cube\n" 
    "//     - writes one output...\n" 
    "#ifdef ACTIVATION_FUNCTION // protect against not defined\n" 
    "void kernel convolve_imagecubes_float2( const int numExamples,\n" 
    "const int numInputPlanes, const int numFilters,\n" 
    "const int inputBoardSize, const int filterSize, const int padZeros,\n" 
    "global const float *images, global const float *filters,\n" 
    "#ifdef BIASED\n" 
    "global const float*biases,\n" 
    "#endif\n" 
    "global float *results ) {\n" 
    "int globalId = get_global_id(0);\n" 
    "\n" 
    "const int evenPadding = filterSize % 2 == 0 ? 1 : 0;\n" 
    "\n" 
    "int inputBoardSizeSquared = inputBoardSize * inputBoardSize;\n" 
    "int outputBoardSize = padZeros ? inputBoardSize + evenPadding : inputBoardSize - filterSize + 1;\n" 
    "int outputBoardSizeSquared = outputBoardSize * outputBoardSize;\n" 
    "int filterSizeSquared = filterSize * filterSize;\n" 
    "\n" 
    "int outputBoard2Id = globalId / outputBoardSizeSquared;\n" 
    "int exampleId = outputBoard2Id / numFilters;\n" 
    "int filterId = outputBoard2Id % numFilters;\n" 
    "\n" 
    "if( exampleId >= numExamples ) {\n" 
    "return;\n" 
    "}\n" 
    "\n" 
    "int inputCubeOffset = exampleId * numInputPlanes * inputBoardSizeSquared;\n" 
    "int filterCubeOffset = filterId * numInputPlanes * filterSizeSquared;\n" 
    "\n" 
    "// intraboard coords\n" 
    "int localid = globalId % outputBoardSizeSquared;\n" 
    "int outputRow = localid / outputBoardSize;\n" 
    "int outputCol = localid % outputBoardSize;\n" 
    "\n" 
    "int halfFilterSize = filterSize >> 1;\n" 
    "float sum = 0;\n" 
    "//  boardsize = oldboardsize\n" 
    "int minm = padZeros ? max( -halfFilterSize, -outputRow ) : -halfFilterSize;\n" 
    "int maxm = padZeros ? min( halfFilterSize - evenPadding, outputBoardSize - 1 - outputRow  - evenPadding) : halfFilterSize - evenPadding;\n" 
    "int minn = padZeros ? max( -halfFilterSize, -outputCol ) : - halfFilterSize;\n" 
    "int maxn = padZeros ? min( halfFilterSize - evenPadding, outputBoardSize - 1 - outputCol - evenPadding) : halfFilterSize - evenPadding;\n" 
    "int inputPlane = 0;\n" 
    "//    float probe = 0;\n" 
    "while( inputPlane < numInputPlanes ) {\n" 
    "int inputBoardOffset = inputCubeOffset + inputPlane * inputBoardSizeSquared;\n" 
    "int filterBoardOffset = filterCubeOffset + inputPlane * filterSizeSquared;\n" 
    "int m = minm;\n" 
    "while( m <= maxm ) {\n" 
    "int inputRow = outputRow + m + ( padZeros ? 0 : halfFilterSize );\n" 
    "int inputboardrowoffset = inputBoardOffset + inputRow * inputBoardSize;\n" 
    "int filterrowoffset = filterBoardOffset + (m+halfFilterSize) * filterSize + halfFilterSize;\n" 
    "int n = minn;\n" 
    "while( n <= maxn ) {\n" 
    "int inputCol = outputCol + n + ( padZeros ? 0 : halfFilterSize );\n" 
    "sum += images[ inputboardrowoffset + inputCol] * filters[ filterrowoffset + n ];\n" 
    "//                probe += 10000 * pown(100, inputPlane) *( inputboardrowoffset + inputCol );\n" 
    "//    probe += pown(100, inputPlane) *( images[inputboardrowoffset + inputCol] );\n" 
    "//probe += pown(100, inputPlane) *( filterrowoffset + n );\n" 
    "//   probe += pown(1000, inputPlane) *( floor(filters[ filterrowoffset + n ]*100)/100 );\n" 
    "\n" 
    "//                sum = filters[filterrowoffset + n];\n" 
    "//sum = filterrowoffset;\n" 
    "n++;\n" 
    "}\n" 
    "m++;\n" 
    "}\n" 
    "//        probe += pown(100, inputPlane ) * filterBoardOffset;\n" 
    "inputPlane++;\n" 
    "}\n" 
    "//     probe = exampleId * 100 + filterCubeOffset;\n" 
    "\n" 
    "#ifdef BIASED\n" 
    "sum += biases[filterId];\n" 
    "#endif\n" 
    "results[globalId] = ACTIVATION_FUNCTION(sum);\n" 
    "//    results[0] = 1234.0;\n" 
    "//     results[1024+globalId] = maxn;\n" 
    "//     results[1] = maxMm;\n" 
    "//     results[2] = minm;\n" 
    "}\n" 
    "#endif\n" 
    "\n" 
    "#ifdef gOutBoardSize // for previous tests that dont define it\n" 
    "#ifdef ACTIVATION_FUNCTION // protect against not defined\n" 
    "// workgroup id organized like: [outplane]\n" 
    "// local id organized like: [outrow][outcol]\n" 
    "// each thread iterates over: [imageid][upstreamplane][filterrow][filtercol]\n" 
    "// number workgroups = 32\n" 
    "// one filter plane takes up 5 * 5 * 4 = 100 bytes\n" 
    "// one filter cube (corresponding to one outplane) = 5*5 * 32 * 4 = 3.2KB (ok)\n" 
    "// all filter cubes = 3.2KB * 32 = 102KB (too big)\n" 
    "// results are organized like [imageid][filterid][row][col]\n" 
    "void kernel convolve_imagecubes_float3( const int batchSize,\n" 
    "global const float *images, global const float *filters,\n" 
    "#ifdef BIASED\n" 
    "global const float*biases,\n" 
    "#endif\n" 
    "global float *results,\n" 
    "local float *_upstreamBoard, local float *_filterCube ) {\n" 
    "const int globalId = get_global_id(0);\n" 
    "\n" 
    "const int evenPadding = gFilterSize % 2 == 0 ? 1 : 0;\n" 
    "\n" 
    "const int workgroupId = get_group_id(0);\n" 
    "const int workgroupSize = get_local_size(0);\n" 
    "const int outPlane = workgroupId;\n" 
    "\n" 
    "const int localId = get_local_id(0);\n" 
    "const int outputRow = localId / gOutBoardSize;\n" 
    "const int outputCol = localId % gOutBoardSize;\n" 
    "\n" 
    "const int minu = gPadZeros ? max( -gHalfFilterSize, -outputRow ) : -gHalfFilterSize;\n" 
    "const int maxu = gPadZeros ? min( gHalfFilterSize - evenPadding, gOutBoardSize - 1 - outputRow  - evenPadding) : gHalfFilterSize - evenPadding;\n" 
    "const int minv = gPadZeros ? max( -gHalfFilterSize, -outputCol ) : - gHalfFilterSize;\n" 
    "const int maxv = gPadZeros ? min( gHalfFilterSize - evenPadding, gOutBoardSize - 1 - outputCol - evenPadding) : gHalfFilterSize - evenPadding;\n" 
    "\n" 
    "const int numUpstreamsPerThread = ( gUpstreamBoardSizeSquared + workgroupSize - 1 ) / workgroupSize;\n" 
    "\n" 
    "const int filterCubeLength = gUpstreamNumPlanes * gFilterSizeSquared;\n" 
    "const int filterCubeGlobalOffset = outPlane * filterCubeLength;\n" 
    "const int numPixelsPerThread = ( filterCubeLength + workgroupSize - 1 ) / workgroupSize;\n" 
    "for( int i = 0; i < numPixelsPerThread; i++ ) {\n" 
    "int thisOffset = localId + i * workgroupSize;\n" 
    "if( thisOffset < filterCubeLength ) {\n" 
    "_filterCube[thisOffset] = filters[filterCubeGlobalOffset + thisOffset];\n" 
    "}\n" 
    "}\n" 
    "// dont need a barrier, since we'll just run behind the barrier from the upstream board download\n" 
    "\n" 
    "for( int n = 0; n < batchSize; n++ ) {\n" 
    "float sum = 0;\n" 
    "for( int upstreamPlane = 0; upstreamPlane < gUpstreamNumPlanes; upstreamPlane++ ) {\n" 
    "int thisUpstreamBoardOffset = ( n * gUpstreamNumPlanes + upstreamPlane ) * gUpstreamBoardSizeSquared;\n" 
    "for( int i = 0; i < numUpstreamsPerThread; i++ ) {\n" 
    "int thisOffset = workgroupSize * i + localId;\n" 
    "if( thisOffset < gUpstreamBoardSizeSquared ) {\n" 
    "_upstreamBoard[ thisOffset ] = images[ thisUpstreamBoardOffset + thisOffset ];\n" 
    "//    if( globalId == 0 ) {\n" 
    "//        for( int i = 0; i < 4; i++ ) {\n" 
    "//            results[14 + i] = thisOffset;\n" 
    "//        }\n" 
    "//    }\n" 
    "}\n" 
    "}\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "int filterBoardOffset = upstreamPlane * gFilterSizeSquared;\n" 
    "for( int u = minu; u <= maxu; u++ ) {\n" 
    "int inputRow = outputRow + u + ( gPadZeros ? 0 : gHalfFilterSize );\n" 
    "int inputboardrowoffset = inputRow * gUpstreamBoardSize;\n" 
    "int filterrowoffset = filterBoardOffset + (u+gHalfFilterSize) * gFilterSize + gHalfFilterSize;\n" 
    "for( int v = minv; v <= maxv; v++ ) {\n" 
    "int inputCol = outputCol + v + ( gPadZeros ? 0 : gHalfFilterSize );\n" 
    "sum += _upstreamBoard[ inputboardrowoffset + inputCol] * _filterCube[ filterrowoffset + v ];\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "#ifdef BIASED\n" 
    "sum += biases[outPlane];\n" 
    "#endif\n" 
    "// results are organized like [imageid][filterid][row][col]\n" 
    "int resultIndex = ( n * gNumOutPlanes + outPlane ) * gOutBoardSizeSquared + localId;\n" 
    "if( localId < gOutBoardSizeSquared ) {\n" 
    "results[resultIndex ] = ACTIVATION_FUNCTION(sum);\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "#endif\n" 
    "#endif\n" 
    "\n" 
    "// images are organized like [imageId][plane][row][col]    128*32*19*19=1,500,000\n" 
    "// filters are organized like [filterid][inplane][filterrow][filtercol] 32*32*5*5=25600 = 100k bytes, or 3.2KB per filter\n" 
    "// results are organized like [imageid][filterid][row][col]   128*32*19*19=1,500,000 = 6MB, or 46KB per image,\n" 
    "//\n" 
    "//                  if w updates are per image,then 25600*128 = 3.3 million\n" 
    "// eg 32 * 32 * 5 * 5 = 25600 ...\n" 
    "// then we are aggregating over [outRow][outCol][n]\n" 
    "//      eg 19 * 19 * 128 = 46208\n" 
    "// derivtype: 0=relu 1=tanh\n" 
    "// outboards(eg 128x32x28x28), errors (eg 128x28x28), upstreamboards (eg 128x32x28x28) => weightchanges (eg 32x32x28x28)\n" 
    "// if break for per-example, per-filter:\n" 
    "// outboard(eg 28x28), error (28x28), upstreamboard(32x28x28) => weightchanges(32x5x5)\n" 
    "//             784 3k         784 3k                 25088 100k                800 3k\n" 
    "// if break for per-filter:\n" 
    "// outboard(eg 128x28x28), error (128x28x28), upstreamboard(128x32x28x28) => weightchanges(32x32x5x5)\n" 
    "//                350k           350k                 12.8MB                   100k\n" 
    "// if break for per-example:\n" 
    "// outboard(eg 28x28), error (28x28), upstreamboard(32x28x28) => weightchanges(32x5x5)\n" 
    "//                3k             3k                 100k                       3k\n" 
    "//    note that weightchanges will need to be summed over 128 input boards\n" 
    "//\n" 
    "// globalid is for: [outPlane][upstreamPlane][filterRow][filterCol]\n" 
    "// per-thread looping over [n][outRow][outCol]\n" 
    "#ifdef ACTIVATION_DERIV // protect against if activation_function not defined\n" 
    "void kernel backprop_floats( const float learningRateMultiplier,\n" 
    "const int batchSize, const int upstreamNumPlanes, const int numPlanes,\n" 
    "const int upstreamBoardSize, const int filterSize, const int outBoardSize, const int padZeros,\n" 
    "global const float *images, global const float *results, global const float *errors, global float *weightChanges ) {\n" 
    "int globalId = get_global_id(0);\n" 
    "\n" 
    "int filterSizeSquared = filterSize * filterSize;\n" 
    "\n" 
    "int IntraFilterOffset = globalId % filterSizeSquared;\n" 
    "int filterRow = IntraFilterOffset / filterSize;\n" 
    "int filterCol = IntraFilterOffset % filterSize;\n" 
    "\n" 
    "int filter2Id = globalId / filterSizeSquared;\n" 
    "int outPlane = filter2Id / upstreamNumPlanes;\n" 
    "int upstreamPlane = filter2Id % upstreamNumPlanes;\n" 
    "\n" 
    "const int halfFilterSize = filterSize >> 1;\n" 
    "const int margin = padZeros ? halfFilterSize : 0;\n" 
    "float thiswchange = 0;\n" 
    "// weights:     [outPlane][upstreamPlane][filterRow][filterCol]\n" 
    "//       aggregate over:  [outRow][outCol][n]\n" 
    "for( int n = 0; n < batchSize; n++ ) {\n" 
    "for( int outRow = 0; outRow < outBoardSize; outRow++ ) {\n" 
    "int upstreamRow = outRow - margin + filterRow;\n" 
    "for( int outCol = 0; outCol < outBoardSize; outCol++ ) {\n" 
    "int upstreamCol = outCol - margin + filterCol;\n" 
    "int resultIndex = ( ( n * numPlanes\n" 
    "+ outPlane ) * outBoardSize\n" 
    "+ outRow ) * outBoardSize\n" 
    "+ outCol;\n" 
    "float error = errors[resultIndex];\n" 
    "float actualOutput = results[resultIndex];\n" 
    "float activationDerivative = ACTIVATION_DERIV( actualOutput);\n" 
    "int upstreamDataIndex = ( ( n * upstreamNumPlanes\n" 
    "+ upstreamPlane ) * upstreamBoardSize\n" 
    "+ upstreamRow ) * upstreamBoardSize\n" 
    "+ upstreamCol;\n" 
    "float upstreamResult = images[upstreamDataIndex];\n" 
    "float thisimagethiswchange = upstreamResult * activationDerivative *\n" 
    "error;\n" 
    "thiswchange += thisimagethiswchange;\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "// weights:     [outPlane][upstreamPlane][filterRow][filterCol]\n" 
    "//       aggregate over:  [outRow][outCol][n]\n" 
    "weightChanges[ globalId ] = - learningRateMultiplier * thiswchange;\n" 
    "}\n" 
    "#endif\n" 
    "\n" 
    "#ifdef ACTIVATION_DERIV // protect against if activation_function not defined\n" 
    "#ifdef gOutBoardSize // for previous tests that dont define it\n" 
    "/*void kernel backprop_floats_2(\n" 
    "const float learningRateMultiplier, const int batchSize, const int workgroupsizenextpower2,\n" 
    "global const float *upstreamBoardsGlobal, global const float *resultsGlobal, global const float *errorsGlobal,\n" 
    "global float *weightChangesGlobal,\n" 
    "local float *_upstreamBoard, local float *_resultBoard, local float *_errorBoard,\n" 
    "local float *_weightChanges, local float *_weightReduceArea ) {\n" 
    "\n" 
    "// required (minimum...) sizes for local arrays:\n" 
    "// upstreamboard: upstreamBoardSizeSquared\n" 
    "// resultboard: outBoardSizeSquared\n" 
    "// errorBoard: outBoardSizeSquaread\n" 
    "// weightChanges: filterSizeSquared\n" 
    "// weightReduceArea: upstreamBoardSizeSquared, or workflowSize, to be decided :-)\n" 
    "const int globalId = get_global_id(0);\n" 
    "const int localId = get_local_id(0);\n" 
    "const int workgroupSize = get_local_size(0);\n" 
    "\n" 
    "const int upstreamBoard2dId = globalId / gUpstreamBoardSizeSquared;\n" 
    "const int upstreamPlane = upstreamBoard2dId % gUpstreamNumPlanes;\n" 
    "const int outPlane2dId = upstreamBoard2dId / gUpstreamNumPlanes;\n" 
    "const int n = outPlane2dId / gNumOutPlanes;\n" 
    "const int outPlane = outPlane2dId % gNumOutPlanes;\n" 
    "\n" 
    "const int outRow = localId / gOutBoardSize;\n" 
    "const int outCol = localId % gOutBoardSize;\n" 
    "\n" 
    "// each localid corresponds to one [upstreamRow][upstreamCol] combination\n" 
    "// we assume that:\n" 
    "// filterSize <= upstreamBoardSize (reasonable... :-) )\n" 
    "// outBoardSize <= upstreamBoardSize (true... unless we have a filter with even size, and padZeros = true )\n" 
    "const int upstreamBoardGlobalOffset = ( n * gUpstreamNumPlanes + upstreamPlane ) * gUpstreamBoardSizeSquared;\n" 
    "\n" 
    "if( localId < gUpstreamBoardSizeSquared ) {\n" 
    "_upstreamBoard[localId] = upstreamBoardsGlobal[upstreamBoardGlobalOffset + localId];\n" 
    "}\n" 
    "int resultBoardGlobalOffset = ( n * gNumOutPlanes + outPlane ) * gOutBoardSizeSquared;\n" 
    "if( localId < gOutBoardSizeSquared ) {\n" 
    "_resultBoard[localId ] = resultsGlobal[resultBoardGlobalOffset + localId];\n" 
    "_errorBoard[localId ] = errorsGlobal[resultBoardGlobalOffset + localId];\n" 
    "_weightReduceArea[localId] = 0;\n" 
    "}\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "\n" 
    "// now we loop over the filter, and the output board...\n" 
    "for( int filterRow = 0; filterRow < gFilterSize; filterRow++ ) {\n" 
    "//        int outRow = upstreamRow + gMargin - filterRow;\n" 
    "int upstreamRow = outRow - gMargin + filterRow;\n" 
    "for( int filterCol = 0; filterCol < gFilterSize; filterCol++ ) {\n" 
    "int upstreamCol = outCol - gMargin + filterCol;\n" 
    "//            int outCol = upstreamCol + gMargin - filterCol;\n" 
    "//            float thiswchange = 0;\n" 
    "int resultIndex = outRow * gOutBoardSize + outCol;\n" 
    "float error = _errorBoard[resultIndex];\n" 
    "float actualOutput = _resultBoard[resultIndex];\n" 
    "float activationDerivative = ACTIVATION_DERIV( actualOutput);\n" 
    "int upstreamDataIndex = upstreamRow * gUpstreamBoardSize + upstreamCol;\n" 
    "float upstreamResult = _upstreamBoard[upstreamDataIndex];\n" 
    "float thisimagethiswchange = upstreamResult * activationDerivative * error;\n" 
    "if( localId < gOutBoardSizeSquared ) {\n" 
    "_weightReduceArea[localId] = thisimagethiswchange;\n" 
    "}\n" 
    "\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "for( int offset = workgroupsizenextpower2 >> 1; offset > 0; offset >>= 1 ) {\n" 
    "if( localId + offset < gOutBoardSizeSquared ) {\n" 
    "_weightReduceArea[localId] = _weightReduceArea[ localId ] + _weightReduceArea[ localId + offset ];\n" 
    "}\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "}\n" 
    "if( localId == 0 ) { // maybe can remove this if? leave for now, so fewer bugs :-)\n" 
    "_weightChanges[filterRow * gFilterSize + filterCol] = _weightReduceArea[0];\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "// oh, we have to reduce again, over n and stuff...\n" 
    "// let's test with a single example and upplane and filter first :-)\n" 
    "// so, we just copy it in for now :-)\n" 
    "if( localId < gFilterSizeSquared ) {\n" 
    "weightChangesGlobal[ localId ] = - learningRateMultiplier * _weightChanges[ localId ];\n" 
    "}\n" 
    "\n" 
    "//    if( localId < gUpstreamBoardSizeSquared ) {\n" 
    "//        weightChangesGlobal[ globalId ] = upstreamBoardsGlobal[globalId];\n" 
    "//        weightChangesGlobal[ globalId ] = _errorBoard[globalId];\n" 
    "//    }\n" 
    "//    weightChangesGlobal[globalId] = resultsGlobal[localId];\n" 
    "// weights:     [outPlane][upstreamPlane][filterRow][filterCol]\n" 
    "//       aggregate over:  [outRow][outCol][n]\n" 
    "//    weightChanges[ globalId ] = - learningRateMultiplier * thiswchange;\n" 
    "}\n" 
    "*/\n" 
    "#endif\n" 
    "#endif\n" 
    "\n" 
    "// need about ~50 workgroups\n" 
    "// eg: - one per n => 128 groups, each one loads:\n" 
    "//                               one cube of input boards (46k :-O )\n" 
    "//                               one cube of output boards (each output cube is 46k too...)\n" 
    "//                               same errors (46k...)\n" 
    "//                               (need to reduce over n)\n" 
    "//     - one per filter => 32 groups, each one loads:\n" 
    "//                               each cube of input boards (eg, sequentially) (each cube is 46k...)\n" 
    "//                               each of its own output planes (eg, sequentially)\n" 
    "//                               each of its own error planes (eg, sequentially)\n" 
    "//                               (no extra-workgroup reduction needed, for boardsize < 19)\n" 
    "//     - one per filter, per upstream => 32*32 = 784 groups. each one loads:\n" 
    "//                               one plane from each cube of boards (eg, sequentially) (1.5k per plane)\n" 
    "//                               one plane from each example output (eg, sequentially) (1.5k per plane)\n" 
    "//                               one plane from each example error (eg, sequentially) (1.5k per plane)\n" 
    "//                               each workgroup will have one thread per board position, ie 384 threads\n" 
    "//                               each thread will iterate over the 25 filter positions\n" 
    "//                               after iterating over all n,\n" 
    "//                                   each workgroup will then give a single w update, 5x5 = 100 bytes\n" 
    "//                                    => written to global memory somewhere\n" 
    "//                               and there will be 784 workgroups to reduce over....\n" 
    "//                                   ... but they will be reduced in blocks of 32, giving a cube of 32 filter board\n" 
    "//                                        updates\n" 
    "//                               (and then need to reduce over upstream boards)\n" 
    "\n" 
    "// if break for per-example, per-filter:\n" 
    "// outboard(eg 28x28), error (28x28), upstreamboard(32x28x28) => weightchanges(32x5x5)\n" 
    "//             784 3k         784 3k                 25088 100k                800 3k\n" 
    "// if break for per-example, per-filter, per-upstream:\n" 
    "// outboard(eg 28x28), error (28x28), upstreamboard(28x28) => weightchanges(5x5)\n" 
    "//             784 3k         784 3k                 784 3k                 25\n" 
    "// n * outplane = 128 * 32 = 4096   , then loop over: [upstreamrow][upstreamcol]\n" 
    "// in this version, workgroups are [outPlane][upstreamPlane]\n" 
    "//                  localid is structured as [upstreamRow][upstreamCol]\n" 
    "//                  globalid is structured as: [outPlane][upstreamPlane]:[upstreamRow][upstreamCol]\n" 
    "//                          each thread should loop over: [n]\n" 
    "//               (and then we will need to reduce each block of 32 filters)\n" 
    "//        (outRow/outCol are locked to upstreamRow/upstreamCol)\n" 
    "// w is [filterRow][filterCol]\n" 
    "// this assumes that filterSizeSquared will fit into one workgroup\n" 
    "//  - which is true for Go-boards, but not for MNIST :-P\n" 
    "//      - so we will test with cropped MNIST images, 19x19, same as go boards :-)\n" 
    "//\n" 
    "// weightChangesGlobal contains one plane from each of the 784 workgroups\n" 
    "// organized as: [outPlane][upstreamPlan]:[filterRow][filterCol] (colon marks gap between\n" 
    "//                       the coordinates per workgroup, and intra-workgroup coordinates )\n" 
    "#ifdef ACTIVATION_DERIV // protect against if activation_function not defined\n" 
    "#ifdef gOutBoardSize // for previous tests that dont define it\n" 
    "/*\n" 
    "void kernel backprop_floats_3(\n" 
    "const float learningRateMultiplier, const int batchSize, const int workgroupsizenextpower2,\n" 
    "global const float *upstreamBoardsGlobal, global const float *resultsGlobal, global const float *errorsGlobal,\n" 
    "global float *weightChangesGlobal,\n" 
    "local float *_upstreamBoard, local float *_resultBoard, local float *_errorBoard,\n" 
    "local float *_weightChanges, local float *_weightReduceArea ) {\n" 
    "\n" 
    "// required (minimum...) sizes for local arrays:\n" 
    "// upstreamboard: upstreamBoardSizeSquared\n" 
    "// resultboard: outBoardSizeSquared\n" 
    "// errorBoard: outBoardSizeSquaread\n" 
    "// weightChanges: filterSizeSquared\n" 
    "// weightReduceArea: upstreamBoardSizeSquared, or workflowSize, to be decided :-)\n" 
    "const int globalId = get_global_id(0);\n" 
    "const int localId = get_local_id(0);\n" 
    "const int workgroupSize = get_local_size(0);\n" 
    "const int workgroupId = get_group_id(0);\n" 
    "\n" 
    "const int outPlane = workgroupId / gUpstreamNumPlanes;\n" 
    "const int upstreamPlane = workgroupId % gUpstreamNumPlanes;\n" 
    "\n" 
    "const int outRow = localId / gOutBoardSize;\n" 
    "const int outCol = localId % gOutBoardSize;\n" 
    "\n" 
    "// wipe _weightChanges first\n" 
    "// dont need a barrier, just use the barrier from loading the other planes from global memory\n" 
    "if( localId < gFilterSizeSquared ) {\n" 
    "_weightChanges[localId] = 0;\n" 
    "}\n" 
    "\n" 
    "for( int n = 0; n < batchSize; n++ ) {\n" 
    "// each localid corresponds to one [upstreamRow][upstreamCol] combination\n" 
    "// we assume that:\n" 
    "// filterSize <= upstreamBoardSize (reasonable... :-) )\n" 
    "// outBoardSize <= upstreamBoardSize (true... unless we have a filter with even size, and padZeros = true )\n" 
    "const int upstreamBoardGlobalOffset = ( n * gUpstreamNumPlanes + upstreamPlane ) * gUpstreamBoardSizeSquared;\n" 
    "if( localId < gUpstreamBoardSizeSquared ) {\n" 
    "_upstreamBoard[localId] = upstreamBoardsGlobal[upstreamBoardGlobalOffset + localId];\n" 
    "}\n" 
    "const int resultBoardGlobalOffset = ( n * gNumOutPlanes + outPlane ) * gOutBoardSizeSquared;\n" 
    "if( localId < gOutBoardSizeSquared ) {\n" 
    "_resultBoard[localId ] = resultsGlobal[resultBoardGlobalOffset + localId];\n" 
    "_errorBoard[localId ] = errorsGlobal[resultBoardGlobalOffset + localId];\n" 
    "_weightReduceArea[localId] = 0; // note: can probably remove this\n" 
    "}\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);  // loaded one upstreamboard, one error plane, one output plane :-)\n" 
    "\n" 
    "// now we loop over the filter, and the output board...\n" 
    "for( int filterRow = 0; filterRow < gFilterSize; filterRow++ ) {\n" 
    "//        int outRow = upstreamRow + gMargin - filterRow;\n" 
    "int upstreamRow = outRow - gMargin + filterRow;\n" 
    "for( int filterCol = 0; filterCol < gFilterSize; filterCol++ ) {\n" 
    "int upstreamCol = outCol - gMargin + filterCol;\n" 
    "//            int outCol = upstreamCol + gMargin - filterCol;\n" 
    "//            float thiswchange = 0;\n" 
    "int resultIndex = outRow * gOutBoardSize + outCol;\n" 
    "float error = _errorBoard[resultIndex];\n" 
    "float actualOutput = _resultBoard[resultIndex];\n" 
    "float activationDerivative = ACTIVATION_DERIV( actualOutput);\n" 
    "int upstreamDataIndex = upstreamRow * gUpstreamBoardSize + upstreamCol;\n" 
    "float upstreamResult = _upstreamBoard[upstreamDataIndex];\n" 
    "float thisimagethiswchange = upstreamResult * activationDerivative * error;\n" 
    "if( localId < gOutBoardSizeSquared ) {\n" 
    "_weightReduceArea[localId] = thisimagethiswchange;\n" 
    "}\n" 
    "\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "for( int offset = workgroupsizenextpower2 >> 1; offset > 0; offset >>= 1 ) {\n" 
    "if( localId + offset < gOutBoardSizeSquared ) {  // cos we're reducing over each position\n" 
    "// in the output board, which this workgroup\n" 
    "// has one thread for each position for\n" 
    "_weightReduceArea[localId] = _weightReduceArea[ localId ] + _weightReduceArea[ localId + offset ];\n" 
    "}\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "}\n" 
    "if( localId == 0 ) {\n" 
    "_weightChanges[filterRow * gFilterSize + filterCol] += _weightReduceArea[0];\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "// now copy our local weightchanges to global memroy\n" 
    "// each thread copies one element\n" 
    "// so need a fence :-)\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "const int weightBoardGlobalOffset = ( outPlane * gUpstreamNumPlanes + upstreamPlane ) * gFilterSizeSquared;\n" 
    "if( localId < gFilterSizeSquared ) {\n" 
    "weightChangesGlobal[weightBoardGlobalOffset + localId ] = - learningRateMultiplier * _weightChanges[ localId ];\n" 
    "}\n" 
    "}\n" 
    "*/\n" 
    "#endif\n" 
    "#endif\n" 
    "\n" 
    "#ifdef ACTIVATION_DERIV // protect against if activation_function not defined\n" 
    "#ifdef gOutBoardSize // for previous tests that dont define it\n" 
    "// 32 workgroups, one per filter\n" 
    "// globalId: [outPlane]:[upstreamRow][upstreamCol]\n" 
    "//   each thread needs to loop over: [n][upstreamPlane][filterRow][filterCol]\n" 
    "/*\n" 
    "void kernel backprop_floats_4(\n" 
    "const float learningRateMultiplier, const int batchSize, const int workgroupsizenextpower2,\n" 
    "global const float *upstreamBoardsGlobal, global const float *resultsGlobal, global const float *errorsGlobal,\n" 
    "global float *weightChangesGlobal,\n" 
    "local float *_upstreamBoard, local float *_resultBoard, local float *_errorBoard,\n" 
    "local float *_weightChanges, local float *_weightReduceArea ) {\n" 
    "\n" 
    "// required (minimum...) sizes for local arrays:\n" 
    "// upstreamboard: upstreamBoardSizeSquared\n" 
    "// resultboard: outBoardSizeSquared\n" 
    "// errorBoard: outBoardSizeSquaread\n" 
    "// weightChanges: filterSizeSquared\n" 
    "// weightReduceArea: upstreamBoardSizeSquared, or workflowSize, to be decided :-)\n" 
    "const int globalId = get_global_id(0);\n" 
    "const int localId = get_local_id(0);\n" 
    "const int workgroupSize = get_local_size(0);\n" 
    "const int workgroupId = get_group_id(0);\n" 
    "\n" 
    "const int outPlane = workgroupId;\n" 
    "\n" 
    "const int outRow = localId / gOutBoardSize;\n" 
    "const int outCol = localId % gOutBoardSize;\n" 
    "\n" 
    "// wipe _weightChanges first\n" 
    "// dont need a barrier, just use the barrier from loading the other planes from global memory\n" 
    "if( localId < gFilterSizeSquared ) {\n" 
    "_weightChanges[localId] = 0;\n" 
    "}\n" 
    "\n" 
    "for( int n = 0; n < batchSize; n++ ) {\n" 
    "const int resultBoardGlobalOffset = ( n * gNumOutPlanes + outPlane ) * gOutBoardSizeSquared;\n" 
    "if( localId < gOutBoardSizeSquared ) {\n" 
    "_resultBoard[localId ] = resultsGlobal[resultBoardGlobalOffset + localId];\n" 
    "_errorBoard[localId ] = errorsGlobal[resultBoardGlobalOffset + localId];\n" 
    "//            _weightReduceArea[localId] = 0; // note: can probably remove this\n" 
    "}\n" 
    "for( int upstreamPlane = 0; upstreamPlane < gUpstreamNumPlanes; upstreamPlane++ ) {\n" 
    "// each localid corresponds to one [upstreamRow][upstreamCol] combination\n" 
    "// we assume that:\n" 
    "// filterSize <= upstreamBoardSize (reasonable... :-) )\n" 
    "// outBoardSize <= upstreamBoardSize (true... unless we have a filter with even size, and padZeros = true )\n" 
    "const int upstreamBoardGlobalOffset = ( n * gUpstreamNumPlanes + upstreamPlane ) * gUpstreamBoardSizeSquared;\n" 
    "if( localId < gUpstreamBoardSizeSquared ) {\n" 
    "_upstreamBoard[localId] = upstreamBoardsGlobal[upstreamBoardGlobalOffset + localId];\n" 
    "}\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);  // loaded one upstreamboard, one error plane, one output plane :-)\n" 
    "\n" 
    "// now we loop over the filter, and the output board...\n" 
    "for( int filterRow = 0; filterRow < gFilterSize; filterRow++ ) {\n" 
    "//        int outRow = upstreamRow + gMargin - filterRow;\n" 
    "int upstreamRow = outRow - gMargin + filterRow;\n" 
    "for( int filterCol = 0; filterCol < gFilterSize; filterCol++ ) {\n" 
    "int upstreamCol = outCol - gMargin + filterCol;\n" 
    "//            int outCol = upstreamCol + gMargin - filterCol;\n" 
    "//            float thiswchange = 0;\n" 
    "int resultIndex = outRow * gOutBoardSize + outCol;\n" 
    "float error = _errorBoard[resultIndex];\n" 
    "float actualOutput = _resultBoard[resultIndex];\n" 
    "float activationDerivative = ACTIVATION_DERIV( actualOutput);\n" 
    "int upstreamDataIndex = upstreamRow * gUpstreamBoardSize + upstreamCol;\n" 
    "float upstreamResult = _upstreamBoard[upstreamDataIndex];\n" 
    "float thisimagethiswchange = upstreamResult * activationDerivative * error;\n" 
    "if( localId < gOutBoardSizeSquared ) {\n" 
    "_weightReduceArea[localId] = thisimagethiswchange;\n" 
    "}\n" 
    "\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "for( int offset = workgroupsizenextpower2 >> 1; offset > 0; offset >>= 1 ) {\n" 
    "if( localId + offset < gOutBoardSizeSquared ) {  // cos we're reducing over each position\n" 
    "// in the output board, which this workgroup\n" 
    "// has one thread for each position for\n" 
    "_weightReduceArea[localId] = _weightReduceArea[ localId ] + _weightReduceArea[ localId + offset ];\n" 
    "}\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "}\n" 
    "if( localId == 0 ) {\n" 
    "_weightChanges[upstreamPlane * gFilterSizeSquared + filterRow * gFilterSize + filterCol] += _weightReduceArea[0];\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "// now copy our local weightchanges to global memroy\n" 
    "// each thread copies one element\n" 
    "// so need a fence :-)\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "const int weightCubeGlobalOffset = outPlane * gUpstreamNumPlanes * gFilterSizeSquared;\n" 
    "if( localId < gFilterSizeSquared ) {\n" 
    "// can flatten this a bit... but probablby not a huge effect. flatten if this kernel is acutllay fast...\n" 
    "for( int upstreamPlane = 0; upstreamPlane < gUpstreamNumPlanes; upstreamPlane++ ) {\n" 
    "int intraCubeOffset = upstreamPlane * gFilterSizeSquared + localId;\n" 
    "weightChangesGlobal[weightCubeGlobalOffset + intraCubeOffset ] = - learningRateMultiplier * _weightChanges[ intraCubeOffset ];\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "*/\n" 
    "#endif\n" 
    "#endif\n" 
    "\n" 
    "// globalid is for: [outPlane][upstreamPlane]:[filterRow][filterCol]\n" 
    "//   workgroup is over [filterRow][filterCol]\n" 
    "// per-thread looping over [n][outRow][outCol]\n" 
    "#ifdef ACTIVATION_DERIV // protect against if activation_function not defined\n" 
    "#ifdef gOutBoardSize // for previous tests that dont define it\n" 
    "void kernel backprop_floats_withscratch(\n" 
    "const float learningRateMultiplier, const int batchSize,\n" 
    "global const float *images, global const float *results, global const float *errors, global float *weightChanges,\n" 
    "local float *_imageBoard, local float *_resultBoard, local float *_errorBoard\n" 
    ") {\n" 
    "const int globalId = get_global_id(0);\n" 
    "const int localId = get_local_id(0);\n" 
    "const int workgroupId = get_group_id(0);\n" 
    "const int workgroupSize = get_local_size(0);\n" 
    "\n" 
    "const int filterRow = localId / gFilterSize;\n" 
    "const int filterCol = localId % gFilterSize;\n" 
    "\n" 
    "const int outPlane = workgroupId / gUpstreamNumPlanes;\n" 
    "const int upstreamPlane = workgroupId % gUpstreamNumPlanes;\n" 
    "\n" 
    "// weights:     [outPlane][upstreamPlane][filterRow][filterCol]\n" 
    "//       aggregate over:  [outRow][outCol][n]\n" 
    "float thiswchange = 0;\n" 
    "for( int n = 0; n < batchSize; n++ ) {\n" 
    "int upstreamBoardGlobalOffset = ( n * gUpstreamNumPlanes + upstreamPlane ) * gUpstreamBoardSizeSquared;\n" 
    "// need to fetch the board, but it's bigger than us, so will need to loop...\n" 
    "int numLoopsForUpstream = ( gUpstreamBoardSizeSquared + workgroupSize - 1 ) / workgroupSize;\n" 
    "for( int i = 0; i < numLoopsForUpstream; i++ ) {\n" 
    "int thisOffset = i * workgroupSize + localId;\n" 
    "if( thisOffset < gUpstreamBoardSizeSquared ) {\n" 
    "_imageBoard[thisOffset] = images[ upstreamBoardGlobalOffset + thisOffset ];\n" 
    "}\n" 
    "}\n" 
    "int resultBoardGlobalOffset = ( n * gNumOutPlanes + outPlane ) * gOutBoardSizeSquared;\n" 
    "int numLoopsForResults = ( gOutBoardSizeSquared + workgroupSize - 1 ) / workgroupSize;\n" 
    "for( int i = 0; i < numLoopsForResults; i++ ) {\n" 
    "int thisOffset = i * workgroupSize + localId;\n" 
    "if( thisOffset < gOutBoardSizeSquared ) {\n" 
    "_resultBoard[thisOffset ] = ( ACTIVATION_DERIV( results[resultBoardGlobalOffset + thisOffset] ) )\n" 
    "* errors[resultBoardGlobalOffset + thisOffset];\n" 
    "}\n" 
    "}\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "for( int outRow = 0; outRow < gOutBoardSize; outRow++ ) {\n" 
    "int upstreamRow = outRow - gMargin + filterRow;\n" 
    "for( int outCol = 0; outCol < gOutBoardSize; outCol++ ) {\n" 
    "int upstreamCol = outCol - gMargin + filterCol;\n" 
    "int resultIndex = outRow * gOutBoardSize + outCol;\n" 
    "float activationDerivative = _resultBoard[resultIndex];\n" 
    "int upstreamDataIndex = upstreamRow * gUpstreamBoardSize + upstreamCol;\n" 
    "float upstreamResult = _imageBoard[upstreamDataIndex];\n" 
    "float thisimagethiswchange = upstreamResult * activationDerivative;\n" 
    "thiswchange += thisimagethiswchange;\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "if( localId < gFilterSizeSquared ) {\n" 
    "weightChanges[ workgroupId * gFilterSizeSquared + localId ] = - learningRateMultiplier * thiswchange;\n" 
    "//        weightChanges[ workgroupId * gFilterSizeSquared + localId ] = workgroupId;\n" 
    "}\n" 
    "// weights:     [outPlane][upstreamPlane][filterRow][filterCol]\n" 
    "//       aggregate over:  [outRow][outCol][n]\n" 
    "}\n" 
    "#endif\n" 
    "#endif\n" 
    "\n" 
    "// biasWeightChanges is: [outplane] (only upstreamplane=0 workgroups need to write it)\n" 
    "#ifdef ACTIVATION_DERIV // protect against if activation_function not defined\n" 
    "#ifdef gOutBoardSize // for previous tests that dont define it\n" 
    "void kernel backprop_floats_withscratch_dobias(\n" 
    "const float learningRateMultiplier, const int batchSize,\n" 
    "global const float *images, global const float *results, global const float *errors, global float *weightChanges, global float *biasWeightChanges,\n" 
    "local float *_imageBoard, local float *_resultBoard, local float *_errorBoard\n" 
    ") {\n" 
    "const int globalId = get_global_id(0);\n" 
    "const int localId = get_local_id(0);\n" 
    "const int workgroupId = get_group_id(0);\n" 
    "const int workgroupSize = get_local_size(0);\n" 
    "\n" 
    "const int filterRow = localId / gFilterSize;\n" 
    "const int filterCol = localId % gFilterSize;\n" 
    "\n" 
    "const int outPlane = workgroupId / gUpstreamNumPlanes;\n" 
    "const int upstreamPlane = workgroupId % gUpstreamNumPlanes;\n" 
    "\n" 
    "// weights:     [outPlane][upstreamPlane][filterRow][filterCol]\n" 
    "//       aggregate over:  [outRow][outCol][n]\n" 
    "float thiswchange = 0;\n" 
    "float thisbiaschange = 0;\n" 
    "for( int n = 0; n < batchSize; n++ ) {\n" 
    "int upstreamBoardGlobalOffset = ( n * gUpstreamNumPlanes + upstreamPlane ) * gUpstreamBoardSizeSquared;\n" 
    "// need to fetch the board, but it's bigger than us, so will need to loop...\n" 
    "int numLoopsForUpstream = ( gUpstreamBoardSizeSquared + workgroupSize - 1 ) / workgroupSize;\n" 
    "for( int i = 0; i < numLoopsForUpstream; i++ ) {\n" 
    "int thisOffset = i * workgroupSize + localId;\n" 
    "if( thisOffset < gUpstreamBoardSizeSquared ) {\n" 
    "_imageBoard[thisOffset] = images[ upstreamBoardGlobalOffset + thisOffset ];\n" 
    "}\n" 
    "}\n" 
    "int resultBoardGlobalOffset = ( n * gNumOutPlanes + outPlane ) * gOutBoardSizeSquared;\n" 
    "int numLoopsForResults = ( gOutBoardSizeSquared + workgroupSize - 1 ) / workgroupSize;\n" 
    "for( int i = 0; i < numLoopsForResults; i++ ) {\n" 
    "int thisOffset = i * workgroupSize + localId;\n" 
    "if( thisOffset < gOutBoardSizeSquared ) {\n" 
    "_resultBoard[thisOffset ] = ( ACTIVATION_DERIV( results[resultBoardGlobalOffset + thisOffset] ) )\n" 
    "* errors[resultBoardGlobalOffset + thisOffset];\n" 
    "}\n" 
    "}\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "for( int outRow = 0; outRow < gOutBoardSize; outRow++ ) {\n" 
    "int upstreamRow = outRow - gMargin + filterRow;\n" 
    "for( int outCol = 0; outCol < gOutBoardSize; outCol++ ) {\n" 
    "int upstreamCol = outCol - gMargin + filterCol;\n" 
    "int resultIndex = outRow * gOutBoardSize + outCol;\n" 
    "float activationDerivative = _resultBoard[resultIndex];\n" 
    "int upstreamDataIndex = upstreamRow * gUpstreamBoardSize + upstreamCol;\n" 
    "float upstreamResult = _imageBoard[upstreamDataIndex];\n" 
    "float thisimagethiswchange = upstreamResult * activationDerivative;\n" 
    "thiswchange += thisimagethiswchange;\n" 
    "thisbiaschange += activationDerivative;\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "if( localId < gFilterSizeSquared ) {\n" 
    "weightChanges[ workgroupId * gFilterSizeSquared + localId ] = - learningRateMultiplier * thiswchange;\n" 
    "//        weightChanges[ workgroupId * gFilterSizeSquared + localId ] = workgroupId;\n" 
    "}\n" 
    "bool writeBias = upstreamPlane == 0 && localId == 0;\n" 
    "if( writeBias ) {\n" 
    "biasWeightChanges[outPlane] = - learningRateMultiplier * thisbiaschange;\n" 
    "}\n" 
    "// weights:     [outPlane][upstreamPlane][filterRow][filterCol]\n" 
    "//       aggregate over:  [outRow][outCol][n]\n" 
    "}\n" 
    "#endif\n" 
    "#endif\n" 
    "\n" 
    "/*\n" 
    "const int outPlane = globalId;\n" 
    "float thiswchange = 0;\n" 
    "for( int n = 0; n < batchSize; n++ ) {\n" 
    "for( int outRow = 0; outRow < gOutBoardSize; outRow++ ) {\n" 
    "for( int outCol = 0; outCol < gOutBoardSize; outCol++ ) {\n" 
    "int resultIndex = ( ( n * gNumOutPlanes\n" 
    "+ outPlane ) * gOutBoardSize\n" 
    "+ outRow ) * gOutBoardSize\n" 
    "+ outCol;\n" 
    "float thisimagethiswchange = errors[resultIndex] * ACTIVATION_DERIV( results[resultIndex] );\n" 
    "thiswchange += thisimagethiswchange;\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "biasWeightChanges[ globalId ] = - learningMultiplier * thiswchange;\n" 
    "*/\n" 
    "\n" 
    "\n" 
    "// globalid is for: [outPlane][upstreamPlane][some filterids]:[some filterids][filterRow][filterCol]\n" 
    "//   workgroup is [a filterid][filterRow][filterCol]\n" 
    "// per-thread looping over [n][outRow][outCol]\n" 
    "// eg if a filter is 5x5, which is 25 values, we can fit 20 of these into one workgroup\n" 
    "// or possibly 16 perhaps, all using the same input board data at the same time\n" 
    "#ifdef ACTIVATION_DERIV // protect against if activation_function not defined\n" 
    "#ifdef gOutBoardSize // for previous tests that dont define it\n" 
    "void kernel backprop_floats_withscratch_batched(\n" 
    "const float learningRateMultiplier, const int batchSize,\n" 
    "global const float *images, global const float *results, global const float *errors, global float *weightChanges,\n" 
    "local float *_imageBoard, local float *_resultBoard, local float *_errorBoard\n" 
    ") {\n" 
    "const int globalId = get_global_id(0);\n" 
    "const int localId = get_local_id(0);\n" 
    "const int workgroupId = get_group_id(0);\n" 
    "const int workgroupSize = get_local_size(0);\n" 
    "\n" 
    "const int filterRow = localId / gFilterSize;\n" 
    "const int filterCol = localId % gFilterSize;\n" 
    "\n" 
    "const int outPlane = workgroupId / gUpstreamNumPlanes;\n" 
    "const int upstreamPlane = workgroupId % gUpstreamNumPlanes;\n" 
    "\n" 
    "// weights:     [outPlane][upstreamPlane][filterRow][filterCol]\n" 
    "//       aggregate over:  [outRow][outCol][n]\n" 
    "float thiswchange = 0;\n" 
    "for( int n = 0; n < batchSize; n++ ) {\n" 
    "int upstreamBoardGlobalOffset = ( n * gUpstreamNumPlanes + upstreamPlane ) * gUpstreamBoardSizeSquared;\n" 
    "// need to fetch the board, but it's bigger than us, so will need to loop...\n" 
    "int numLoopsForUpstream = ( gUpstreamBoardSizeSquared + workgroupSize - 1 ) / workgroupSize;\n" 
    "for( int i = 0; i < numLoopsForUpstream; i++ ) {\n" 
    "int thisOffset = i * workgroupSize + localId;\n" 
    "if( thisOffset < gUpstreamBoardSizeSquared ) {\n" 
    "_imageBoard[thisOffset] = images[ upstreamBoardGlobalOffset + thisOffset ];\n" 
    "}\n" 
    "}\n" 
    "int resultBoardGlobalOffset = ( n * gNumOutPlanes + outPlane ) * gOutBoardSizeSquared;\n" 
    "int numLoopsForResults = ( gOutBoardSizeSquared + workgroupSize - 1 ) / workgroupSize;\n" 
    "for( int i = 0; i < numLoopsForResults; i++ ) {\n" 
    "int thisOffset = i * workgroupSize + localId;\n" 
    "if( thisOffset < gOutBoardSizeSquared ) {\n" 
    "_resultBoard[thisOffset ] = ( ACTIVATION_DERIV( results[resultBoardGlobalOffset + thisOffset] ) )\n" 
    "* errors[resultBoardGlobalOffset + thisOffset];\n" 
    "}\n" 
    "}\n" 
    "barrier(CLK_LOCAL_MEM_FENCE);\n" 
    "for( int outRow = 0; outRow < gOutBoardSize; outRow++ ) {\n" 
    "int upstreamRow = outRow - gMargin + filterRow;\n" 
    "for( int outCol = 0; outCol < gOutBoardSize; outCol++ ) {\n" 
    "int upstreamCol = outCol - gMargin + filterCol;\n" 
    "int resultIndex = outRow * gOutBoardSize + outCol;\n" 
    "float activationDerivative = _resultBoard[resultIndex];\n" 
    "int upstreamDataIndex = upstreamRow * gUpstreamBoardSize + upstreamCol;\n" 
    "float upstreamResult = _imageBoard[upstreamDataIndex];\n" 
    "float thisimagethiswchange = upstreamResult * activationDerivative;\n" 
    "thiswchange += thisimagethiswchange;\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "if( localId < gFilterSizeSquared ) {\n" 
    "weightChanges[ workgroupId * gFilterSizeSquared + localId ] = - learningRateMultiplier * thiswchange;\n" 
    "//        weightChanges[ workgroupId * gFilterSizeSquared + localId ] = workgroupId;\n" 
    "}\n" 
    "// weights:     [outPlane][upstreamPlane][filterRow][filterCol]\n" 
    "//       aggregate over:  [outRow][outCol][n]\n" 
    "}\n" 
    "#endif\n" 
    "#endif\n" 
    "\n" 
    "// handle lower layer...\n" 
    "// errors for upstream look like [n][inPlane][inRow][inCol]\n" 
    "// need to aggregate over: [outPlane][outRow][outCol] (?)\n" 
    "// need to backprop errors along each possible weight\n" 
    "// each upstream feeds to:\n" 
    "//    - each of our filters (so numPlanes filters)\n" 
    "//    - each of our outpoint points (so boardSize * boardSize)\n" 
    "// errors are provider per [n][inPlane][inRow][inCol]\n" 
    "// globalid is structured as: [n][upstreamPlane][upstreamRow][upstreamCol]\n" 
    "// there will be approx 128 * 32 * 28 * 28 = 3 million threads :-P\n" 
    "// grouped into 4608 workgroups\n" 
    "// maybe we want fewer than this?\n" 
    "void kernel calcErrorsForUpstream(\n" 
    "const int upstreamNumPlanes, const int upstreamBoardSize, const int filterSize,\n" 
    "const int outNumPlanes, const int outBoardSize,\n" 
    "const int padZeros,\n" 
    "global const float *weights, global const float *errors, global float *errorsForUpstream ) {\n" 
    "int globalId = get_global_id(0);\n" 
    "const int halfFilterSize = filterSize >> 1;\n" 
    "const int margin = padZeros ? halfFilterSize : 0;\n" 
    "\n" 
    "const int upstreamBoardSizeSquared = upstreamBoardSize * upstreamBoardSize;\n" 
    "const int upstreamBoard2dId = globalId / upstreamBoardSizeSquared;\n" 
    "\n" 
    "const int intraBoardOffset = globalId % upstreamBoardSizeSquared;\n" 
    "const int upstreamRow = intraBoardOffset / upstreamBoardSize;\n" 
    "const int upstreamCol = intraBoardOffset % upstreamBoardSize;\n" 
    "\n" 
    "const int upstreamPlane = upstreamBoard2dId % upstreamNumPlanes;\n" 
    "const int n = upstreamBoard2dId / upstreamNumPlanes;\n" 
    "\n" 
    "const int minFilterRow = max( 0, upstreamRow + margin - (outBoardSize - 1) );\n" 
    "const int maxFilterRow = min( filterSize - 1, upstreamRow + margin );\n" 
    "const int minFilterCol = max( 0, upstreamCol + margin - (outBoardSize -1) );\n" 
    "const int maxFilterCol = min( filterSize - 1, upstreamCol + margin );\n" 
    "\n" 
    "float sumWeightTimesOutError = 0;\n" 
    "// aggregate over [outPlane][outRow][outCol]\n" 
    "for( int outPlane = 0; outPlane < outNumPlanes; outPlane++ ) {\n" 
    "for( int filterRow = minFilterRow; filterRow <= maxFilterRow; filterRow++ ) {\n" 
    "int outRow = upstreamRow + margin - filterRow;\n" 
    "for( int filterCol = minFilterCol; filterCol <= maxFilterCol; filterCol++ ) {\n" 
    "int outCol = upstreamCol + margin - filterCol;\n" 
    "int resultIndex = ( ( n * outNumPlanes\n" 
    "+ outPlane ) * outBoardSize\n" 
    "+ outRow ) * outBoardSize\n" 
    "+ outCol;\n" 
    "float thisError = errors[resultIndex];\n" 
    "int thisWeightIndex = ( ( outPlane * upstreamNumPlanes\n" 
    "+ upstreamPlane ) * filterSize\n" 
    "+ filterRow ) * filterSize\n" 
    "+ filterCol;\n" 
    "float thisWeight = weights[thisWeightIndex];\n" 
    "float thisWeightTimesError = thisWeight * thisError;\n" 
    "sumWeightTimesOutError += thisWeightTimesError;\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "errorsForUpstream[globalId] = sumWeightTimesOutError;\n" 
    "}\n" 
    "\n" 
    "// how about we make each workgroup handle one upstream plane, and iterate over examples?\n" 
    "// for now we assume that a workgroup is large enough to have one thread per location\n" 
    "// but we could always simply make each thread handle two pixels I suppose :-)\n" 
    "// so, workgroupId is [upstreamPlane]\n" 
    "// localId is [upstreamRow][upstreamCol]\n" 
    "// we iterate over [n]\n" 
    "#ifdef gOutBoardSize // for previous tests that dont define it\n" 
    "/*\n" 
    "void kernel calcErrorsForUpstream2(\n" 
    "const int batchSize,\n" 
    "global const float *weightsGlobal, global const float *errorsGlobal,\n" 
    "global float *errorsForUpstreamGlobal,\n" 
    "local float *_weightBoard, local float *_errorBoard ) {\n" 
    "const int globalId = get_global_id(0);\n" 
    "const int workgroupId = get_group_id(0);\n" 
    "const int localId = get_local_id(0);\n" 
    "const int workgroupSize = get_local_size(0);\n" 
    "\n" 
    "const int upstreamPlane = workgroupId;\n" 
    "const int upstreamRow = localId / gUpstreamBoardSize;\n" 
    "const int upstreamCol = localId % gUpstreamBoardSize;\n" 
    "\n" 
    "const int\n" 
    "if( localId < filterSizeSquared ) {\n" 
    "_weightBoard[localId] = weightsGlobal[localId];\n" 
    "}\n" 
    "\n" 
    "for( int n = 0; n < batchSize; n++ ) {\n" 
    "float sumWeightTimesOutError = 0;\n" 
    "// aggregate over [outPlane][outRow][outCol]\n" 
    "for( int outPlane = 0; outPlane < outNumPlanes; outPlane++ ) {\n" 
    "for( int outRow = 0; outRow < outBoardSize; outRow++ ) {\n" 
    "// need to derive filterRow and filterCol, given outRow and outCol\n" 
    "int filterRow = upstreamRow + margin - outRow;\n" 
    "for( int outCol = 0; outCol < outBoardSize; outCol++ ) {\n" 
    "// need to derive filterRow and filterCol, given outRow and outCol\n" 
    "int filterCol = upstreamCol + margin - outCol;\n" 
    "int resultIndex = ( ( n * outNumPlanes\n" 
    "+ outPlane ) * outBoardSize\n" 
    "+ outRow ) * outBoardSize\n" 
    "+ outCol;\n" 
    "float thisError = errors[resultIndex];\n" 
    "int thisWeightIndex = ( ( outPlane * upstreamNumPlanes\n" 
    "+ upstreamPlane ) * filterSize\n" 
    "+ filterRow ) * filterSize\n" 
    "+ filterCol;\n" 
    "float thisWeight = weights[thisWeightIndex];\n" 
    "float thisWeightTimesError = thisWeight * thisError;\n" 
    "sumWeightTimesOutError += thisWeightTimesError;\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "errorsForUpstream[globalId] = sumWeightTimesOutError;\n" 
    "}\n" 
    "}\n" 
    "*/\n" 
    "#endif\n" 
    "\n" 
    "// so, we're just going to convolve the errorcubes with our filter cubes...\n" 
    "// like propagate, but easier, since no activation function, and no biases\n" 
    "// errorcubes (*) filters => errors\n" 
    "// for propagation we had:\n" 
    "//   images are organized like [imageId][plane][row][col]\n" 
    "//   filters are organized like [filterid][inplane][filterrow][filtercol]\n" 
    "//   results are organized like [imageid][filterid][row][col]\n" 
    "//   global id is organized like results, ie: [imageid][filterid][row][col]\n" 
    "//   - no local memory used currently\n" 
    "//   - each thread:\n" 
    "//     - loads a whole board\n" 
    "//     - loads a whole filter\n" 
    "//     - writes one output\n" 
    "// we will have the other way around:\n" 
    "//   errorcubes are organized like [imageid][outPlane][outRow][outCol]\n" 
    "//   filters are organized like [filterid][inplane][filterrow][filtercol]\n" 
    "//        (so we will swap filterid and inplane around when referencing filters, kindof)\n" 
    "//  globalid will be organized like upstreamresults, ie [imageid][upstreamplane][upstreamrow][upstreamcol]\n" 
    "#ifdef gOutBoardSize // for previous tests that dont define it\n" 
    "void kernel convolve_errorcubes_float(\n" 
    "const int batchSize,\n" 
    "global const float *errorcubes, global const float *filters,\n" 
    "global float *upstreamErrors ) {\n" 
    "int globalId = get_global_id(0);\n" 
    "\n" 
    "int upstreamBoard2Id = globalId / gUpstreamBoardSizeSquared;\n" 
    "int exampleId = upstreamBoard2Id / gUpstreamNumPlanes;\n" 
    "int filterId = upstreamBoard2Id % gUpstreamNumPlanes;\n" 
    "\n" 
    "if( exampleId >= batchSize ) {\n" 
    "return;\n" 
    "}\n" 
    "/*\n" 
    "int errorCubeOffset = exampleId * gNumOutPlanes * gOutBoardSizeSquared;\n" 
    "int filterCubeOffset = filterId * gNumInputPlanes * gFilterSizeSquared;\n" 
    "\n" 
    "int localid = globalId % upstreamBoardSizeSquared;\n" 
    "int upstreamRow = localid / gUpstreamBoardSize;\n" 
    "int upstreamCol = localid % gUpstreamBoardSize;\n" 
    "\n" 
    "float sum = 0;\n" 
    "// ====in progress\n" 
    "int minm = padZeros ? max( -halfFilterSize, -outputRow ) : -halfFilterSize;\n" 
    "// ====to do\n" 
    "int maxm = padZeros ? min( halfFilterSize, outputBoardSize - 1 - outputRow ) : halfFilterSize;\n" 
    "int minn = padZeros ? max( -halfFilterSize, -outputCol ) : - halfFilterSize;\n" 
    "int maxn = padZeros ? min( halfFilterSize, outputBoardSize - 1 - outputCol ) : halfFilterSize;\n" 
    "int inputPlane = 0;\n" 
    "while( inputPlane < numInputPlanes ) {\n" 
    "int inputBoardOffset = inputCubeOffset + inputPlane * inputBoardSizeSquared;\n" 
    "int filterBoardOffset = filterCubeOffset + inputPlane * filterSizeSquared;\n" 
    "int m = minm;\n" 
    "while( m <= maxm ) {\n" 
    "int inputRow = outputRow + m + ( padZeros ? 0 : halfFilterSize );\n" 
    "int inputboardrowoffset = inputBoardOffset + inputRow * inputBoardSize;\n" 
    "int filterrowoffset = filterBoardOffset + (m+halfFilterSize) * filterSize + halfFilterSize;\n" 
    "int n = minn;\n" 
    "while( n <= maxn ) {\n" 
    "int inputCol = outputCol + n + ( padZeros ? 0 : halfFilterSize );\n" 
    "sum += images[ inputboardrowoffset + inputCol] * filters[ filterrowoffset + n ];\n" 
    "n++;\n" 
    "}\n" 
    "m++;\n" 
    "}\n" 
    "inputPlane++;\n" 
    "}\n" 
    "results[globalId] = sum;*/\n" 
    "}\n" 
    "#endif\n" 
    "\n" 
    "// doesnt have to be fast, just has to be on gpu is only requirement really...\n" 
    "// make globalid be [outplane]\n" 
    "// and localid is also [outplane]\n" 
    "// so, one workgroup, internally structured as [outplane] (unless there are >512 outplanes....)\n" 
    "#ifdef gOutBoardSize // for previous tests that dont define it\n" 
    "kernel void doBiasBackprop( const float learningMultiplier, const int batchSize,\n" 
    "global float const *results, global float const *errors, global float *biasWeightChanges ) {\n" 
    "const int globalId = get_local_id(0);\n" 
    "\n" 
    "const int outPlane = globalId;\n" 
    "\n" 
    "// bias...\n" 
    "// biasweights: [outPlane]\n" 
    "//       aggregate over:  [upstreamPlane][filterRow][filterCol][outRow][outCol][n]\n" 
    "float thiswchange = 0;\n" 
    "for( int n = 0; n < batchSize; n++ ) {\n" 
    "for( int outRow = 0; outRow < gOutBoardSize; outRow++ ) {\n" 
    "for( int outCol = 0; outCol < gOutBoardSize; outCol++ ) {\n" 
    "int resultIndex = ( ( n * gNumOutPlanes\n" 
    "+ outPlane ) * gOutBoardSize\n" 
    "+ outRow ) * gOutBoardSize\n" 
    "+ outCol;\n" 
    "float thisimagethiswchange = errors[resultIndex] * ACTIVATION_DERIV( results[resultIndex] );\n" 
    "thiswchange += thisimagethiswchange;\n" 
    "}\n" 
    "}\n" 
    "}\n" 
    "if( globalId < gNumOutPlanes ) {\n" 
    "biasWeightChanges[ globalId ] = - learningMultiplier * thiswchange;\n" 
    "}\n" 
    "}\n" 
    "#endif\n" 
    "\n" 
    "kernel void add_in_place( const int N, global const float*in, global float*target ) {\n" 
    "int globalId = get_global_id(0);\n" 
    "if( globalId < N ) {\n" 
    "target[globalId] += in[globalId];\n" 
    "}\n" 
    "}\n" 
    "\n" 
    "\n" 
    "";
    // [[[end]]]
//    kernel = cl->buildKernel( "../ClConvolve.cl", "convolve_imagecubes_float2", "-D " + fn->getDefineName() );
    kernel = cl->buildKernel( kernelSource, "-D " + fn->getDefineName() );
}
VIRTUAL Propagate1::~Propagate1() {
    delete kernel;
}
VIRTUAL void Propagate1::propagate( int batchSize, CLWrapper *dataWrapper, CLWrapper *weightsWrapper, CLWrapper *biasWeightsWrapper,
    CLWrapper *resultsWrapper ) {
    kernel->in(batchSize)
        ->in( dim.inputPlanes )->in( dim.numFilters )
        ->in( dim.inputBoardSize )->in( dim.filterSize )
       ->in( dim.padZeros ? 1 : 0 );
    kernel->input( dataWrapper );
    kernel->input( weightsWrapper);
    if( dim.biased ) kernel->input( biasWeightsWrapper );
    kernel->output( resultsWrapper );

    int globalSize = batchSize * dim.numFilters * square( dim.outputBoardSize );
    int workgroupsize = std::min( globalSize, cl->getMaxWorkgroupSize() );
    globalSize = ( ( globalSize + workgroupsize - 1 ) / workgroupsize ) * workgroupsize;
    cout << " globalsize " << globalSize << " workgroupsize " << workgroupsize << endl;

    kernel->run_1d( globalSize, workgroupsize );
    cl->finish();
}

