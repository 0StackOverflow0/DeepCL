# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_PyDeepCL', [dirname(__file__)])
        except ImportError:
            import _PyDeepCL
            return _PyDeepCL
        if fp is not None:
            try:
                _mod = imp.load_module('_PyDeepCL', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _PyDeepCL = swig_import_helper()
    del swig_import_helper
else:
    import _PyDeepCL
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class GenericLoader(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericLoader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenericLoader, name)
    __repr__ = _swig_repr
    __swig_getmethods__["getDimensions"] = lambda x: _PyDeepCL.GenericLoader_getDimensions
    if _newclass:getDimensions = staticmethod(_PyDeepCL.GenericLoader_getDimensions)
    def __init__(self): 
        this = _PyDeepCL.new_GenericLoader()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDeepCL.delete_GenericLoader
    __del__ = lambda self : None;
GenericLoader_swigregister = _PyDeepCL.GenericLoader_swigregister
GenericLoader_swigregister(GenericLoader)

def GenericLoader_getDimensions(*args):
  return _PyDeepCL.GenericLoader_getDimensions(*args)
GenericLoader_getDimensions = _PyDeepCL.GenericLoader_getDimensions


def GenericLoader_load(*args):
  return _PyDeepCL.GenericLoader_load(*args)
GenericLoader_load = _PyDeepCL.GenericLoader_load
class LayerMaker2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LayerMaker2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LayerMaker2, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _PyDeepCL.delete_LayerMaker2
    __del__ = lambda self : None;
    def clone(self): return _PyDeepCL.LayerMaker2_clone(self)
LayerMaker2_swigregister = _PyDeepCL.LayerMaker2_swigregister
LayerMaker2_swigregister(LayerMaker2)

class NeuralNet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NeuralNet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NeuralNet, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDeepCL.new_NeuralNet(*args)
        try: self.this.append(this)
        except: self.this = this
    def addLayer(self, *args): return _PyDeepCL.NeuralNet_addLayer(self, *args)
    def setBatchSize(self, *args): return _PyDeepCL.NeuralNet_setBatchSize(self, *args)
    def forward(self, *args): return _PyDeepCL.NeuralNet_forward(self, *args)
    def backwardFromLabels(self, *args): return _PyDeepCL.NeuralNet_backwardFromLabels(self, *args)
    def backward(self, *args): return _PyDeepCL.NeuralNet_backward(self, *args)
    def calcNumRight(self, *args): return _PyDeepCL.NeuralNet_calcNumRight(self, *args)
    def getOutputSize(self): return _PyDeepCL.NeuralNet_getOutputSize(self)
    def asString(self): return _PyDeepCL.NeuralNet_asString(self)
    def getOutput(self, *args): return _PyDeepCL.NeuralNet_getOutput(self, *args)
    __swig_destroy__ = _PyDeepCL.delete_NeuralNet
    __del__ = lambda self : None;
NeuralNet_swigregister = _PyDeepCL.NeuralNet_swigregister
NeuralNet_swigregister(NeuralNet)

class NetdefToNet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetdefToNet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NetdefToNet, name)
    __repr__ = _swig_repr
    __swig_getmethods__["createNetFromNetdef"] = lambda x: _PyDeepCL.NetdefToNet_createNetFromNetdef
    if _newclass:createNetFromNetdef = staticmethod(_PyDeepCL.NetdefToNet_createNetFromNetdef)
    def __init__(self): 
        this = _PyDeepCL.new_NetdefToNet()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDeepCL.delete_NetdefToNet
    __del__ = lambda self : None;
NetdefToNet_swigregister = _PyDeepCL.NetdefToNet_swigregister
NetdefToNet_swigregister(NetdefToNet)

def NetdefToNet_createNetFromNetdef(*args):
  return _PyDeepCL.NetdefToNet_createNetFromNetdef(*args)
NetdefToNet_createNetFromNetdef = _PyDeepCL.NetdefToNet_createNetFromNetdef

class NetLearner(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetLearner, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NetLearner, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDeepCL.new_NetLearner(*args)
        try: self.this.append(this)
        except: self.this = this
    def setSchedule(self, *args): return _PyDeepCL.NetLearner_setSchedule(self, *args)
    def learn(self, *args): return _PyDeepCL.NetLearner_learn(self, *args)
    __swig_destroy__ = _PyDeepCL.delete_NetLearner
    __del__ = lambda self : None;
NetLearner_swigregister = _PyDeepCL.NetLearner_swigregister
NetLearner_swigregister(NetLearner)

class NormalizationLayerMaker(LayerMaker2):
    __swig_setmethods__ = {}
    for _s in [LayerMaker2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NormalizationLayerMaker, name, value)
    __swig_getmethods__ = {}
    for _s in [LayerMaker2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NormalizationLayerMaker, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _PyDeepCL.new_NormalizationLayerMaker()
        try: self.this.append(this)
        except: self.this = this
    def translate(self, *args): return _PyDeepCL.NormalizationLayerMaker_translate(self, *args)
    def scale(self, *args): return _PyDeepCL.NormalizationLayerMaker_scale(self, *args)
    def clone(self): return _PyDeepCL.NormalizationLayerMaker_clone(self)
    def getTranslate(self): return _PyDeepCL.NormalizationLayerMaker_getTranslate(self)
    def getScale(self): return _PyDeepCL.NormalizationLayerMaker_getScale(self)
    def show(self): return _PyDeepCL.NormalizationLayerMaker_show(self)
    __swig_destroy__ = _PyDeepCL.delete_NormalizationLayerMaker
    __del__ = lambda self : None;
NormalizationLayerMaker_swigregister = _PyDeepCL.NormalizationLayerMaker_swigregister
NormalizationLayerMaker_swigregister(NormalizationLayerMaker)

class InputLayerMaker(LayerMaker2):
    __swig_setmethods__ = {}
    for _s in [LayerMaker2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InputLayerMaker, name, value)
    __swig_getmethods__ = {}
    for _s in [LayerMaker2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InputLayerMaker, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _PyDeepCL.new_InputLayerMaker()
        try: self.this.append(this)
        except: self.this = this
    def numPlanes(self, *args): return _PyDeepCL.InputLayerMaker_numPlanes(self, *args)
    def imageSize(self, *args): return _PyDeepCL.InputLayerMaker_imageSize(self, *args)
    def clone(self): return _PyDeepCL.InputLayerMaker_clone(self)
    def getPlanes(self): return _PyDeepCL.InputLayerMaker_getPlanes(self)
    def getSize(self): return _PyDeepCL.InputLayerMaker_getSize(self)
    def show(self): return _PyDeepCL.InputLayerMaker_show(self)
    __swig_destroy__ = _PyDeepCL.delete_InputLayerMaker
    __del__ = lambda self : None;
InputLayerMaker_swigregister = _PyDeepCL.InputLayerMaker_swigregister
InputLayerMaker_swigregister(InputLayerMaker)

class ConvolutionalMaker(LayerMaker2):
    __swig_setmethods__ = {}
    for _s in [LayerMaker2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConvolutionalMaker, name, value)
    __swig_getmethods__ = {}
    for _s in [LayerMaker2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConvolutionalMaker, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _PyDeepCL.new_ConvolutionalMaker()
        try: self.this.append(this)
        except: self.this = this
    def numFilters(self, *args): return _PyDeepCL.ConvolutionalMaker_numFilters(self, *args)
    def filterSize(self, *args): return _PyDeepCL.ConvolutionalMaker_filterSize(self, *args)
    def padZeros(self, *args): return _PyDeepCL.ConvolutionalMaker_padZeros(self, *args)
    def biased(self, *args): return _PyDeepCL.ConvolutionalMaker_biased(self, *args)
    def clone(self): return _PyDeepCL.ConvolutionalMaker_clone(self)
    __swig_destroy__ = _PyDeepCL.delete_ConvolutionalMaker
    __del__ = lambda self : None;
ConvolutionalMaker_swigregister = _PyDeepCL.ConvolutionalMaker_swigregister
ConvolutionalMaker_swigregister(ConvolutionalMaker)

class FullyConnectedMaker(LayerMaker2):
    __swig_setmethods__ = {}
    for _s in [LayerMaker2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FullyConnectedMaker, name, value)
    __swig_getmethods__ = {}
    for _s in [LayerMaker2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FullyConnectedMaker, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _PyDeepCL.new_FullyConnectedMaker()
        try: self.this.append(this)
        except: self.this = this
    def numPlanes(self, *args): return _PyDeepCL.FullyConnectedMaker_numPlanes(self, *args)
    def imageSize(self, *args): return _PyDeepCL.FullyConnectedMaker_imageSize(self, *args)
    def biased(self, *args): return _PyDeepCL.FullyConnectedMaker_biased(self, *args)
    def clone(self): return _PyDeepCL.FullyConnectedMaker_clone(self)
    __swig_destroy__ = _PyDeepCL.delete_FullyConnectedMaker
    __del__ = lambda self : None;
FullyConnectedMaker_swigregister = _PyDeepCL.FullyConnectedMaker_swigregister
FullyConnectedMaker_swigregister(FullyConnectedMaker)

class PoolingMaker(LayerMaker2):
    __swig_setmethods__ = {}
    for _s in [LayerMaker2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PoolingMaker, name, value)
    __swig_getmethods__ = {}
    for _s in [LayerMaker2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PoolingMaker, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _PyDeepCL.new_PoolingMaker()
        try: self.this.append(this)
        except: self.this = this
    def poolingSize(self, *args): return _PyDeepCL.PoolingMaker_poolingSize(self, *args)
    def clone(self): return _PyDeepCL.PoolingMaker_clone(self)
    __swig_destroy__ = _PyDeepCL.delete_PoolingMaker
    __del__ = lambda self : None;
PoolingMaker_swigregister = _PyDeepCL.PoolingMaker_swigregister
PoolingMaker_swigregister(PoolingMaker)

class SoftMaxMaker(LayerMaker2):
    __swig_setmethods__ = {}
    for _s in [LayerMaker2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SoftMaxMaker, name, value)
    __swig_getmethods__ = {}
    for _s in [LayerMaker2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SoftMaxMaker, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _PyDeepCL.new_SoftMaxMaker()
        try: self.this.append(this)
        except: self.this = this
    def perColumn(self): return _PyDeepCL.SoftMaxMaker_perColumn(self)
    def perPlane(self): return _PyDeepCL.SoftMaxMaker_perPlane(self)
    def clone(self): return _PyDeepCL.SoftMaxMaker_clone(self)
    __swig_destroy__ = _PyDeepCL.delete_SoftMaxMaker
    __del__ = lambda self : None;
SoftMaxMaker_swigregister = _PyDeepCL.SoftMaxMaker_swigregister
SoftMaxMaker_swigregister(SoftMaxMaker)

class SquareLossMaker(LayerMaker2):
    __swig_setmethods__ = {}
    for _s in [LayerMaker2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SquareLossMaker, name, value)
    __swig_getmethods__ = {}
    for _s in [LayerMaker2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SquareLossMaker, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _PyDeepCL.new_SquareLossMaker()
        try: self.this.append(this)
        except: self.this = this
    def clone(self): return _PyDeepCL.SquareLossMaker_clone(self)
    __swig_destroy__ = _PyDeepCL.delete_SquareLossMaker
    __del__ = lambda self : None;
SquareLossMaker_swigregister = _PyDeepCL.SquareLossMaker_swigregister
SquareLossMaker_swigregister(SquareLossMaker)

class CrossEntropyLossMaker(LayerMaker2):
    __swig_setmethods__ = {}
    for _s in [LayerMaker2]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CrossEntropyLossMaker, name, value)
    __swig_getmethods__ = {}
    for _s in [LayerMaker2]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CrossEntropyLossMaker, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _PyDeepCL.new_CrossEntropyLossMaker()
        try: self.this.append(this)
        except: self.this = this
    def clone(self): return _PyDeepCL.CrossEntropyLossMaker_clone(self)
    __swig_destroy__ = _PyDeepCL.delete_CrossEntropyLossMaker
    __del__ = lambda self : None;
CrossEntropyLossMaker_swigregister = _PyDeepCL.CrossEntropyLossMaker_swigregister
CrossEntropyLossMaker_swigregister(CrossEntropyLossMaker)

class floatArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, floatArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, floatArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDeepCL.new_floatArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDeepCL.delete_floatArray
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _PyDeepCL.floatArray___getitem__(self, *args)
    def __setitem__(self, *args): return _PyDeepCL.floatArray___setitem__(self, *args)
    def cast(self): return _PyDeepCL.floatArray_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _PyDeepCL.floatArray_frompointer
    if _newclass:frompointer = staticmethod(_PyDeepCL.floatArray_frompointer)
floatArray_swigregister = _PyDeepCL.floatArray_swigregister
floatArray_swigregister(floatArray)

def floatArray_frompointer(*args):
  return _PyDeepCL.floatArray_frompointer(*args)
floatArray_frompointer = _PyDeepCL.floatArray_frompointer

class intArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, intArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, intArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDeepCL.new_intArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDeepCL.delete_intArray
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _PyDeepCL.intArray___getitem__(self, *args)
    def __setitem__(self, *args): return _PyDeepCL.intArray___setitem__(self, *args)
    def cast(self): return _PyDeepCL.intArray_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _PyDeepCL.intArray_frompointer
    if _newclass:frompointer = staticmethod(_PyDeepCL.intArray_frompointer)
intArray_swigregister = _PyDeepCL.intArray_swigregister
intArray_swigregister(intArray)

def intArray_frompointer(*args):
  return _PyDeepCL.intArray_frompointer(*args)
intArray_frompointer = _PyDeepCL.intArray_frompointer

class QLearner2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, QLearner2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, QLearner2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDeepCL.new_QLearner2(*args)
        try: self.this.append(this)
        except: self.this = this
    def step(self, *args): return _PyDeepCL.QLearner2_step(self, *args)
    def setLambda(self, *args): return _PyDeepCL.QLearner2_setLambda(self, *args)
    def setMaxSamples(self, *args): return _PyDeepCL.QLearner2_setMaxSamples(self, *args)
    def setEpsilon(self, *args): return _PyDeepCL.QLearner2_setEpsilon(self, *args)
    def setLearningRate(self, *args): return _PyDeepCL.QLearner2_setLearningRate(self, *args)
    __swig_destroy__ = _PyDeepCL.delete_QLearner2
    __del__ = lambda self : None;
QLearner2_swigregister = _PyDeepCL.QLearner2_swigregister
QLearner2_swigregister(QLearner2)

class floatSlice(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, floatSlice, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, floatSlice, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDeepCL.new_floatSlice(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDeepCL.delete_floatSlice
    __del__ = lambda self : None;
    def cast(self): return _PyDeepCL.floatSlice_cast(self)
floatSlice_swigregister = _PyDeepCL.floatSlice_swigregister
floatSlice_swigregister(floatSlice)

class intSlice(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, intSlice, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, intSlice, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDeepCL.new_intSlice(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDeepCL.delete_intSlice
    __del__ = lambda self : None;
    def cast(self): return _PyDeepCL.intSlice_cast(self)
intSlice_swigregister = _PyDeepCL.intSlice_swigregister
intSlice_swigregister(intSlice)

# This file is compatible with both classic and new-style classes.


